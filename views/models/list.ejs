<h1 id="title"></h1>

<div class="actions">
  <a href="/"><- Back</a>
  <a id="add-new" style="float:right">Add new</a>
</div>

<table>
  <thead>
    <tr>
      <!-- Generated Code -->
    </tr>
  </thead>
  <tbody>

  </tbody>
</table>

<script type="text/javascript">

const ModelList = class {
  constructor(modelName, attributes) {
    this.modelName = modelName;
    this.attributes = attributes;
  }

  /**
  * Gets the data for the current model
  * @return A promise to use to get the records
  */
  getRecords() {
    return fetch(`/${this.modelName}`).then(response => response.json());
  };

  /**
  * Sorts the attributes of the attributes object in a user friendly order
  * @return an array with the sorted keys
  */
  getSortedAttributes() {
    const firstItems = ['id', 'name'];
    const secondItems = ['createdAt', 'updatedAt'];
    let sortedAttributes = [];

    // Sort attributes in a user friendly order
    sortedAttributes = Object.keys(this.attributes) // get array of keys
    .filter( // take out pre-indexed items
      item => firstItems.indexOf(item) == -1 &&
      secondItems.indexOf(item) == -1
    )
    .sort();

    // prepend first items and append last items
    sortedAttributes = firstItems.concat(sortedAttributes, secondItems);

    // Convert the attributes back to their objects
    sortedAttributes = sortedAttributes.map(attr => {
      const thingToReturn = {};
      thingToReturn[attr] = this.attributes[attr];
      return thingToReturn;
    });

    return sortedAttributes;
  }

  /**
  * Converts the value given to a user friendly string
  * @param attributeValue the value to convert
  * @param attribute the attribute object itself, specifying its properties
  */
  getFriendlyValueName(attributeValue, attribute){
    if(!attributeValue) {
      return null;
    } else if (attribute.collection) {
      return `${attributeValue.length} ${attribute.collection}`;
    } else if(attribute.model){
      return attributeValue.name;
    } else if(['datetime'].indexOf(attribute.type) != -1) {

      const pad = number => {
        number = number.toString();
        return number.length == 1 ? `0${number}` : number;
      }
      const date = new Date(attributeValue);
      return date.toUTCString();

    } else {
      return attributeValue;
    }
  }

  /**
   * Deletes a record from the db
   * @return a promise for the delete event
   */
   deleteRecord(record) {
     return fetch(`/${modelList.modelName}/${record.id}`, {
       'method': 'DELETE',
       'body': record
     });
   }
};

// Instantiate the class
const modelList = new ModelList('<%= req.params.model %>', <%- JSON.stringify(sails.models[req.params.model].attributes) %>);

// Create table headers
{
  const theadTr = document.querySelector('table thead tr');
  const editTh = document.createElement('th');

  document.getElementById('title').innerHTML = `${modelList.modelName}`;
  document.getElementById('add-new').href = `/models/${modelList.modelName}/create`;
  editTh.innerHTML = 'Edit';
  theadTr.appendChild(editTh);

  // convert attributes to th
  modelList.getSortedAttributes().forEach(attr => {
    const keys = Object.keys(attr);
    const name = keys[0];
    const properties = attr[name];
    const th = document.createElement('th');

    th.innerHTML = name;
    theadTr.appendChild(th);
  });

  const deleteTh = document.createElement('th');
  deleteTh.innerHTML = 'Delete';
  theadTr.appendChild(deleteTh);
}

// Display the data
modelList.getRecords().then(data => {
  data.forEach(item => {
    // For loop that run for each record in table
    const deleteTd = document.createElement('td');
    const deleteLink = document.createElement('a');
    const editTd = document.createElement('td');
    const editLink = document.createElement('a');
    const tr = document.createElement('tr');

    editLink.innerHTML = 'Edit';
    editLink.href = `/models/${modelList.modelName}/${item.id}`;
    editTd.appendChild(editLink);

    deleteLink.innerHTML = 'Delete';
    deleteLink.href = `/models/${modelList.modelName}`;
    deleteLink.onclick = event => {
      event.preventDefault();
      const warningMessage = `Are you sure you want to delete this item?\n\n${JSON.stringify(item)}`;
      if(confirm(warningMessage)){
        modelList.deleteRecord(item).then(response => {
          location.href = deleteLink.href;
        });
      }
    }
    deleteTd.appendChild(deleteLink);
    tr.appendChild(editTd);

    // For loop that runs for each attrubte of a record
    modelList.getSortedAttributes().forEach(attr => {
      const keys = Object.keys(attr);
      const attrName = keys[0];
      const attrProperties = attr[attrName];
      const value = item[attrName];
      const td = document.createElement('td');
      let name = modelList.getFriendlyValueName(value, attrProperties);

      // If the attribute is a foreign model, make it a link to that model.
      if(attrProperties.model){
        if(value){
          const a = document.createElement('a');
          a.innerHTML = name;
          a.href = `/models/${attrProperties.model}/${value.id}`;
          a.title = `#${value.id}`; // hover
          td.appendChild(a);
        } else {
          td.title = `null`;
        }
      } else {
        // If not a foreign key

        // If the current attribute is a collection (1-to-N relationship)
        if(attrProperties.collection){
          const button = document.createElement('button'); // Expand / shrink button
          const container = document.createElement('div');
          const expandCode = '˅';
          const shrinkCode = '˄';
          const span = document.createElement('span'); // The value (the text)

          container.classList.add('container');
          container.classList.add('container-flex-center');
          button.classList.add('expand-shrink-button');

          button.innerHTML = expandCode;
          // Handler function for when the button is clicked
          button.addEventListener('click', event => {
            // Convert the button to a shrink icon
            let isExpanded = button.innerHTML == shrinkCode;
            button.innerHTML = isExpanded ? expandCode : shrinkCode;

            if(isExpanded){

            } else {
              /**
               * 1. Convert the other TDs into rowspan = the number of items
               * 2. Split the td (with the collection) into multiple tds (specifically, into the amount of items)
               */

               const elementsClickedOn = event.path;
               const clickedTd = elementsClickedOn.filter(element => element.tagName == 'TD')[0];
               const tdContainer = clickedTd.getElementsByClassName('container')[0];
               const clickedTr = elementsClickedOn.filter(element => element.tagName == 'TR')[0];
               const tds = clickedTr.getElementsByTagName('td');

              //  For each td in the tr
               for(let i = 0; i < tds.length; i++){
                 const td = tds[i];

                // If the current td is not the one they clicked on
                 if(td != clickedTd){
                   td.setAttribute('rowspan', value.length); // value.length == number of items in collection
                 }
               }

               const clickedTable = elementsClickedOn.filter(element => element.tagName == 'TABLE')[0];

               const newA = document.createElement('a');
               newA.innerHTML = value[0].name;
               newA.href = `/models/${attrProperties.collection}/${value[0].id}`;
               tdContainer.insertBefore(newA, tdContainer.firstChild);
               tdContainer.getElementsByClassName('value')[0].style.display = 'none';

               for(let i = 1; i < value.length; i++){
                 const newTr = document.createElement('tr');
                 const newTD = document.createElement('td');
                 const newA = document.createElement('a');

                 newA.innerHTML = value[i].name;
                 newA.href = `/models/${attrProperties.collection}/${value[i].id}`;
                 newTD.appendChild(newA);
                 newTr.appendChild(newTD);

                 clickedTr.parentNode.insertBefore(newTr, clickedTr.nextSibling);
               }
            }

          });
          span.innerHTML = name;
          span.classList.add('value');

          container.appendChild(span);
          container.appendChild(button);

          td.appendChild(container);
        } else {
          td.innerHTML = value;
        }

      }
      tr.appendChild(td);
      document.querySelector('table tbody').appendChild(tr);
    });

    tr.appendChild(deleteTd);

  });
});

</script>
